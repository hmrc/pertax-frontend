

module.exports = class NoUnnecessaryDoubleQuotes

    rule:
        name: 'no_unnecessary_double_quotes'
        level: 'ignore'
        message: 'Unnecessary double quotes are forbidden'
        description: '''
            This rule prohibits double quotes unless string interpolation is
            used or the string contains single quotes.
            <pre>
            <code># Double quotes are discouraged:
            foo = "bar"

            # Unless string interpolation is used:
            foo = "#{bar}baz"

            # Or they prevent cumbersome escaping:
            foo = "I'm just following the 'rules'"
            </code>
            </pre>
            Double quotes are permitted by default.
            '''
    constructor: ->
        @regexps = []

    tokens: ['STRING']

    lintToken: (token, tokenApi) ->
        tokenValue = token[1]

        i = tokenApi.i

        stringValue = tokenValue.match(/^\"(.*)\"$/)

        # Upon seeing first regexp, create cache of regexp locations
        @regexps = @getBlockRegExps(tokenApi) if @regexps.length is 0
        notInBlock = (1 for [s, e] in @regexps when s < i < e).length is 0
        # no double quotes, all OK
        return false unless stringValue and notInBlock

        hasLegalConstructs = @isInterpolated(tokenApi) or
            @containsSingleQuote(tokenValue)

        return not hasLegalConstructs

    getBlockRegExps: (tokenApi) ->
        { lines, tokens } = tokenApi
        regexps = []
        # Only add regexps that are from the block regexp shorthand and not
        # from ones where the user actually uses the `RegExp` function.
        for t, i in tokens when t[0] is 'IDENTIFIER' and t[1] is 'RegExp'
            { first_line: lin, first_column: col } = t[2]
            if lines[lin][col..(col + 2)] is "///"
                regexps.push([i, 0])

        # Find where the regexp calls end, anything inbetween these tokens
        # we will ignore any double-quotes.
        for [i], idx in regexps
            ii = 2
            callEnds = 1
            # Handle function calls inside of regexp
            while (callEnds > 0 and curTok = tokens[i + ii][0])
                callEnds-- if curTok is 'CALL_END'
                callEnds++ if curTok is 'CALL_START'
                ii++
            regexps[idx][1] = i + ii - 1
        return regexps

    isInterpolated: (tokenApi) ->
        { i: idx } = tokenApi
        isInterpolated = false

        # Traverse backwards to find signs that the current string token is
        # generated by the coffee rewriter for string interpolation
        for i in [1..idx]
            token = tokenApi.peek(-i)
            # If there are no previous tokens this loop must be done.  This
            # happens when your file starts with a quoted string like "use
            # strict"
            unless token?
                break
            tokenName = token[0]

            if tokenName is ')' and token.stringEnd
                break # No interpolation, we can quit
            else if tokenName is '(' and
                    token.origin?[1] is 'string interpolation'
                isInterpolated = true
                break

        return isInterpolated

    containsSingleQuote: (tokenValue) ->
        return tokenValue.indexOf("'") isnt -1
